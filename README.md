## ЛР №2
## Группа: Ит-6-2024 (ЛА-4)
## ФИО: Пигилев Константин Дмитриевич

## Описание ЛР
Решение всех задач оформить в виде функций, решающими поставленные задачи. В главной функции 
main организовать вызов всех функций с дружественным интерфейсом. Если исходные данные 
вводятся с клавиатуры, то организовать проверку на ввод. 

В заданиях 1, 2, 3 элементами контейнеров являются целые числа. Для заполнения контейнера 
использовать итератор и конструктор соответствующего контейнера, для вывода элементов 
использовать итератор (для вывода элементов в обратном порядке использовать обратные 
итераторы, возвращаемые функциями-членами rbegin и rend). 

В задании 4 обработка данных выполняется без использования контейнеров. Если алгоритм требует 
применения функционального объекта, следует использовать лямбда-выражения. Использовать 
итераторы istream_iterator и ostream_iterator. 

Если в заданиях 5, 6, 7, 8, 9, 10 тип элементов контейнера не указан, то предполагается, что 
элементами являются целые числа. 

Необходимо решить по 1 задаче из каждого задания согласно вашему варианту. Задания 1-7 оценивается по 
0,5 балла, задания 8-10 по 1,5 балла. Максимально за лабораторную работу можно получить 10 баллов (8 
баллов за решение задач + 2 балла за оформление отчета). 

## Задание 1: №6
Даны вектор V, дек D и список L. Каждый исходный контейнер содержит не менее трех элементов, количество элементов является нечетным. Удвоить значения первого, среднего и последнего элемента каждого из исходных контейнеров. 

### Алгоритм решения:
1. Получаем по ссылке List, Deq и Vector
2. Находим середины каждого из контенеров
3. При помощи циклов изменяем первый, средний и последний элемент

### Тестирование:
<img width="1823" height="937" alt="image" src="https://github.com/user-attachments/assets/d153b358-4f65-4e1d-9c39-efc32c6af860" />

<img width="1826" height="728" alt="image" src="https://github.com/user-attachments/assets/3258843e-b67d-4046-8529-e070bfe4f812" />

---
## Задание 2: №4
Даны вектор V и список L. Каждый исходный контейнер содержит не менее 5 элементов. Вставить после элемента списка с порядковым номером 5 первые 5 элементов вектора в обратном порядке. Использовать один вызов функции-члена insert.

### Алгоритм решения:
1. Получаем вектор не по ссылке и список по ссылке
2. Создаем итератор списка и переносим его на позицию после 5 элемента
3. Создаем пустой вектор на 5 элементов и заполняем его первыми пятью элементами исходного вектора
4. Для списка использую метод insert с параметрами:
   1) итератор, указывающий на 6 поз;
   2) итератор, указывающий на конец нового вектора;
   3) итератор, указывающий на начало нового вектора;

То есть элементы вектора вставляются в список на позицию 6 в обратном порядке.

### Тестирование:
<img width="1925" height="707" alt="image" src="https://github.com/user-attachments/assets/e3a9c661-8607-4f1e-a433-b229f8d5d618" />

---
## Задание 3: №9
Дан дек D с количеством элементов, кратным 4. Удалить в первой половине исходного дека все элементы с четными порядковыми номерами (считая, что начальный элемент дека имеет порядковый номер 1). Использовать функцию-член erase в цикле с числовым параметром. Указание. Используйте цикл с числовым параметром, повторяющийся N/4 раз (где N — исходный размер дека). Свяжите вспомогательный итератор i с началом дека. В цикле выполняйте функцию-член erase с параметром, равным ++i, обязательно присваивая возвращаемое значение итератору i. 

### Алгоритм решения:
1. Получаем deq по ссылке
2. Находим длину очереди и ставим итератор на начало deq
3. Циклом проходимся по очереди N/4 раз и удаляем в первой половине все элементы с четными порядковыми номерами при помощи метода erase


### Тестирование:
<img width="1817" height="551" alt="image" src="https://github.com/user-attachments/assets/eee9aa25-aaa5-4b09-80d3-2e2c7778d783" />

---
## Задание 4: №3
Дан набор вещественных чисел, содержащий не менее двух элементов. Вывести числа из исходного набора с четными порядковыми номерами (т. е. второе число, четвертое число и т. д.). Использовать алгоритм remove_copy_if. 

### Алгоритм решения:
1. Создаем два итератора, которые указываю на начало ввода и на конец
2. Создаем итератор вывода, чтобы он ставил пробелы между элементами
3. Используем алгоритм remove_copy_if, который принимает в себя 4 параметра:
     1) итератор, начала диапазона
     2) итератор, конца диапазона
     3) итератор вывода
     4) лямбда-функция, которая проверяет четность номеров из исходног набора
4. Очищаем ввод, чтобы была возможность выхода из функции

### Тестирование:
<img width="1425" height="238" alt="image" src="https://github.com/user-attachments/assets/72f41659-b94f-41d5-af69-e673307bdf31" />

<img width="1435" height="236" alt="image" src="https://github.com/user-attachments/assets/25fd5ce1-db6d-4d31-b048-a234d98e01b3" />

<img width="1424" height="264" alt="image" src="https://github.com/user-attachments/assets/ab02d4d2-6eaf-4d76-b219-431043168b6a" />

---
## Задание 5: №5
Дан список L, содержащий как отрицательные, так и положительные элементы. Вставить нулевой элемент после первого отрицательного элемента и перед последним положительным элементом. Использовать два вызова алгоритма find_if и два вызова функции-члена insert. Указание. По поводу использования алгоритма find_if с обратным итератором см. указание к задаче 5.2. Указание. Алгоритм find может возвращать обратный итератор, однако функция-член erase не позволяет его использовать дляудаления элемента. Необходимо перейти от обратного итератора r к связанному с ним обычному итератору, используя функцию-член обратного итератора r.base(). При этом следует учитывать, что функция r.base() возвращает итератор, связанный с элементом, следующим за тем, с которым связан обратный итератор r. Поэтому в функции-члене erase следует указать одно из следующих выражений (предполагается, что r — это обратный итератор, который вернул алгоритм find, и этот итератор отличен от rend): -r.base() или (++r).base(). 

### Алгоритм решения:
1. Сохраняем первый элемент списка
2. Используя find_if, находим первое включение отрицательного числа
3. При помощи insert вставляем нулевой элемент после первого отрицательного числа
4. Использую find_if, идем с конца списка и ищем первое вхождение положительного элемента
5. При помощи insert вставляем нулевой элемент после первого положительного числа с конца, при этом перевернув итератор списка

### Тестирование:
<img width="2027" height="415" alt="image" src="https://github.com/user-attachments/assets/0211f7f5-7ec2-4e2d-b80e-d08222650068" />

<img width="2028" height="294" alt="image" src="https://github.com/user-attachments/assets/e6e74548-f301-409f-a97d-7bdcec9b90e8" />

<img width="2015" height="268" alt="image" src="https://github.com/user-attachments/assets/32be32e5-6ff4-4996-81f6-10428c2956cc" />

---
## Задание 6: №14
Дан вектор V с четным количеством элементов. Решить для него задачу 6.13. Поскольку операция вставки в начало вектора делает все его итераторы недействительными, для решения задачи использовать вспомогательный вектор V0. Инициализировать вектор V0 второй половиной элементов вектора V, после чего применить алгоритм remove_copy_if, используя вектор V0 как источник, а вектор V как приемник данных. 
6.13: Скопировать в начало вектора все положительные элементы, расположенные в его второй половине, сохранив для них исходный порядок следования.

### Алгоритм решения:
1. Скопировать в новый вектор V0 вторую половину исходного вектора
2. При помощи алгоритма remove_copy_if в начало исходного вектора копируем все положительные элементы вектора v0, проверяя их лямбда-функцией.

### Тестирование:
<img width="1726" height="564" alt="image" src="https://github.com/user-attachments/assets/2d9bc43a-e790-4940-b784-a38f512d3a10" />

<img width="1734" height="410" alt="image" src="https://github.com/user-attachments/assets/460425e1-e828-4d23-9ad4-672c88ba50e2" />

---
## Задание 7: №11
Дан дек D, элементами которого являются английские слова. Отсортировать его элементы по убыванию их длин, а элементы одинаковой длины — в алфавитном порядке. Использовать единственный вызов алгоритма sort с параметром — функциональным объектом, включающим как сравнение строк, так и сравнение их длин. 

### Алгоритм решения:
1. В сортировке указываем начало, конец deq'а и лямбда-функцию
2. Лямбда-функция принимает первую и следующую строку, сначала проверяет по длине, если совпадают, тогда сортирует по алфавиту
### Тестирование:
<img width="1922" height="263" alt="image" src="https://github.com/user-attachments/assets/85ea0485-71c4-4df9-8b2b-5a5f8ced120b" />

---
## Задание 8: №1
Дан список L. Получить вектор V вещественных чисел, содержащий значения среднего арифметического для всех пар соседних элементов исходного списка (количество элементов вектора V должно быть на 1 меньше количества элементов списка L). Например, для исходного списка 1, 3, 4, 6 полученный вектор должен содержать значения 2.0, 3.5, 5.0. Использовать алгоритм adjacent_difference с итератором вставки и функциональным объектом, а также функцию-член erase для вектора V.

### Алгоритм решения:
1. Создаем новый вектора длинной исходного вектора
2. При помощи алгоритма adjacent_difference находим среднее значение между сосденими парами
3. Алгоритм adjacent_difference на первой итерации копирует элемент исходного вектора, поэтому при помощи erase удалем первый элемент вектора

### Тестирование:
<img width="1796" height="449" alt="image" src="https://github.com/user-attachments/assets/852caac1-307c-458a-a427-44707e652b6d" />

<img width="1831" height="484" alt="image" src="https://github.com/user-attachments/assets/3113e5e5-9da3-436a-a9ef-5b07b603cf6f" />

---
## Задание 9: №1
Дан вектор V0, целое число N (> 0) и набор векторов V1, …, VN. Известно, что размер вектора V0 не превосходит размера любого из векторов V1, …, VN. Найти количество векторов VI, I = 1, …, N, в которых содержатся все элементы вектора V0 (без учета их повторений). Использовать алгоритм includes, применяя его в цикле к двум множествам, одно из которых создано на основе вектора V0, а другое на очередной итерации содержит элементы очередного из векторов VI, I = 1, …, N. 

### Алгоритм решения:
1. Передаем исходный вектор и набор из векторов
2. Исходный вектор пребразовываем в множество
3. Создаем цикл, в котором проходимся по каждому вектору и преобразоываем его в множество
4. При помощи includes проверяем содержится ли текущее множество в исходном
5. Считаем
   
### Тестирование:
<img width="1710" height="570" alt="image" src="https://github.com/user-attachments/assets/b614bb88-7434-4274-bb5d-4f215692c7d6" />

<img width="1702" height="446" alt="image" src="https://github.com/user-attachments/assets/12cbca5e-ea6a-4097-baef-4a0eee09e310" />


---
## Задание 10: №2
Дан вектор V, элементами которого являются английские слова, набранные заглавными буквами. Определить суммарную длину слов, начинающихся с одной и той же буквы, и вывести все различные буквы, с которых начинаются элементы вектора V, вместе с суммарной длиной этих элементов (в алфавитном порядке букв); длину выводить сразу после соответствующей буквы. Использовать вспомогательное отображение M, ключами которого являются начальные буквы элементов вектора V, а значениями — суммарная длина этих элементов. При заполнении отображения M не использовать условные конструкции (достаточно операций индексирования [], инкремента и функции-члена size для строк). Элементы вектора V (при заполнении отображения M) и элементы отображения M (при выводе полученных результатов) перебирать в цикле с параметром-итератором соответствующего контейнера.

### Алгоритм решения:
1. Принимаем вектор строк
2. Создаем map с ключ-значениями char-int
3. Циклом проходимся по вектору и заносим в словарь ключ(первая буква слова) - значение(длина слова)
4. Длина слова добавляется к значению одного и того же ключа

### Тестирование:
<img width="1226" height="190" alt="image" src="https://github.com/user-attachments/assets/1bfdc255-a5db-440e-a4c0-f142656d4dab" />
